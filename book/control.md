# Control Flow

## If
```aratar
let a: 4
if a = 2 | 3 {
    log("This shouldn't happen, as `a` is 4 - not 2 or 3")
}
```

## Else
```aratar
let a Int: 4
if Int.Text {
    log("The number 4 can be turned into text: ", a)
} else a = 4 {
    log("This shouldn't happen")
} else {
    log("This shouldn't happen, either")
}
```

## Logic
Logic is done in a way inspired by Lisp:

```aratar
let a: 4
if all(a = 4, a.Text) {
    log("It works!")
}
```

 - `all(values [Bool]) -> Bool`: Returns true if they're all true (AND)
 - `one(values [Bool]) -> Bool`: Returns true if only one is true (XOR)
 - `any(values [Bool]) -> Bool`: Returns true if any are true (IOR)
 - `not(values [Bool]) -> Bool`: Returns true if none are true (NOR)

## If Let
While similar to Rust's `if let`, has significant differences:

```aratar
let a: Some(4)
if let Some(b): a {
    # â€¦
}
```

## Match
Match statements test equivalence (`=`).  They are slightly different than
Rust's.  They are a newline separated list of closures or scopes assigned to
each variant.

```aratar
let a: Some(4)
match a
on Some(b) => {}
on None => {}
```

You can use 1-equivalence to make your code shorter:

```aratar
opt LotsOfValues [
    A(Int, Int, Int)
    B(Int, Int, Int)
]

let la: LotsOfValues.A(1, 2, 3)

match la
on A(a, b, c) => log(a, " ", b, " ", c)
on B(0, 0, c) => log("A and B are 0, C is: ", c)
on B(tuple) => log(tuple.0, " ", tuple.1, " ", tuple.2)
```

You can also specialize your code based on which type is used:

```aratar
rec A()
rec B()

def specialized[T: A | B](var: T) {
    match T
    on A() => log("Specialized A Code")
    on B() => log("Specialized B Code")
}

pub def run() {
    specialized(A()) # Prints "Specialized A Code"
    specialized(B()) # Prints "Specialized B Code"
}
```

This works because types and constants are the same thing in Aratar (constants
are types with one possible value).  Enum variants are also types, and can be
used as such.

## Iteration
```aratar
let a: @[1, 2, 3, 4]

for @value: a {
    value -: 1
    log(value)
}
```

## Asynchronous Iteration
Because `Screen` and `InputListener` are infinite iterators, you must wrap them
in an `Until` iterator.  The thing about `Until` is that the first parameter
must be a type that exists in the second parameter's set of possible values.
This makes it impossible to make a program that can never stop - note however
that if the user never does anything the program will run forever.

```aratar
pub def run() {
    let screen: sys.Screen("My Application Name")
    let input: sys.Input()
    let listener: sys.Listener(screen, input)

    for event: listener.until(Key(Back)) {
        match event
        on Draw(canvas) => canvas.redraw(0, 255, 0)
        on _ => { }
    }
}
```

## Simple Iteration
```aratar
for i: Range(0, 5) {
    log(i)
}
```

## Implementing Iterators
The following is the implementation for `Range`.

```aratar
# An iterable range.
struct Range[T: Int](
    start T,
    end T,
)

struct Range.Iter(
    let generator: Fn(self, yield) {
        let iter: [(); Ord.max(0, self.end - self.start)].Iter().Enumerate()
        for (i, ()); iter {
            yield(i + self.start)
        }
    }
    return generator.Iter()
)



# Define the constructor, there may only be one.
def Range[T](start T, end T):
    Range(start: start, end: end)

# Implement conversion to Iter for Range.
def Range[T].Iter[T] {
    Iter(yield) {

    }
}
```

```aratar
lib asdf 1.0.0

# Make option type: Maybe
pub opt Maybe[T] [
    Some(T)
    None
]

# The iterator trait.
pub rec Iter[T]()

# Require generator function for trait.
def Iter[T].generator(self, Fn(T))

# Type generated by Iter.Enumerate
rec Enumerate[T](
    inner: Iter[T]
)

# Implement Iter for Enumerate
pub def Enumerate.Iter.generator(iter, yield) {
    let i: @0
    for t: self.inner {
        yield(i, t)
        i +: 1
    }
}

# Implement constructor from generator function.
pub def Iter(generator) -> Iter {
    Iter [
        generator: self
    ]
}

# Implement method to return Enumerate type.
pub def Iter.enumerate(self) -> Enumerate {
    Enumerate [
        inner: self
    ]
}
```

## Conditional Methods
```aratar
let b: false
let c: true
let a: any(b, c).then_else(1, 2)
```
