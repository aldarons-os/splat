// Nahar - Plop Grizzly - <jeron.lau@plopgrizzly.com>
//
// Copyright Jeron A. Lau 2018.
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at
// https://www.boost.org/LICENSE_1_0.txt)

use std::fs;
use std::fs::File;
use std::io::BufReader;
use std::io::prelude::*;
use std::env;
use std::process::Command;

#[derive(PartialEq)]
enum Block {
	Rem, // # or ##
	Mod, // mod - module exports
	Obj, // obj - object exports
	Dep, // dep - dependency imports
	Fun, // fun - function
	Var, // var - variable
	Con, // con - constant
	Mac, // mac - macro
	Ffi, // ffi - foreign function interface
	Fvi, // fvi - foreign variable interface
	Set, // set - set a built-in function for this module or object.
}

fn main() -> std::io::Result<()> {
	let mut output = "// Auto-Generated by nr\n".to_string();
	output.push_str("#include <stdio.h>\n");
	output.push_str("#include <stdint.h>\n");
	output.push_str("int main(int argc, char* argv[]) {\n");
	let args: Vec<String> = env::args().collect();
	if args.len() < 2 {
		println!("usage: nr <input_filename.nr>");
		::std::process::exit(255);
	}

	let input: String = args[1].to_string();
	let file = File::open(input)?;
	let mut buf_reader = BufReader::new(file);
//	let mut contents = String::new();
//	buf_reader.read_to_string(&mut contents)?;

	let mut stack = vec![];

	for (num, line) in buf_reader.lines().enumerate() {
		let mut l: &str = &line.unwrap();
		let mut indentation = 0;

		// ignore bogus whitespace
		if l.is_empty() { continue }

		while l.starts_with("\t") {
			l = &l[1..];
			indentation += 1;
		}

		println!("{}\t|{}", num + 1, l);

		stack.truncate(indentation);

		if let Some(a) = stack.last() {
			match *a {
				Block::Rem => {
					continue;
				}
				_ => {},
			}
		}

		// Comment section
		match l {
			"#" => {
				stack.push(Block::Rem);
			}
			_ => {}
		}
	}

	output.push_str("}");

	let mut file = File::create(".nr_tmp.c")?;
	file.write_fmt(format_args!("{}", output))?;

	if !Command::new("gcc")
		.arg("-O3")
		.arg(".nr_tmp.c").spawn().unwrap().wait().unwrap().success()
	{
		panic!("Failed to compile this fool.");
	}

	if !Command::new("strip")
		.arg("-s")
		.arg("a.out").spawn().unwrap().wait().unwrap().success()
	{
		panic!("Failed to compile this fool.");
	}

// FIXME: Do later, now is testing time.
//	fs::remove_file(".nr_tmp.c")?;

	Ok(())
}
