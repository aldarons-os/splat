use std::fs;
use std::fs::File;
use std::io::BufReader;
use std::io::prelude::*;
use std::env;
use std::process::Command;

#[derive(PartialEq)]
enum Block {
	Comment,
	Unsafe,
	Function(String),
	Match,
	C,
}

fn main() -> std::io::Result<()> {
	let mut output = "// Auto-Generated by Splat!\n".to_string();
	output.push_str("#include <stdio.h>\n");
	output.push_str("#include <stdint.h>\n");
	output.push_str("int main(int argc, char* argv[]) {\n");
	let args: Vec<String> = env::args().collect();
	if args.len() < 2 {
		println!("usage: splat <input_filename.splat>");
		::std::process::exit(255);
	}

	let input: String = args[1].to_string();
	let file = File::open(input)?;
	let mut buf_reader = BufReader::new(file);
//	let mut contents = String::new();
//	buf_reader.read_to_string(&mut contents)?;

	let mut stack = vec![];

	for (num, line) in buf_reader.lines().enumerate() {
		let mut l: &str = &line.unwrap();
		let mut indentation = 0;

		// ignore bogus whitespace
		if l.is_empty() { continue }

		while l.starts_with("\t") {
			l = &l[1..];
			indentation += 1;
		}

		println!("{}\t|{}", num + 1, l);

		stack.truncate(indentation);

		if let Some(a) = stack.last() {
			match *a {
				Block::Comment => {
					continue;
				}
				Block::C => {
					output += l;
					output.push_str(";\n");
					continue;
				}
				_ => {},
			}
		}

		// Comment section
		match l {
			"###" => {
				stack.push(Block::Comment);
			}
			"|C|" => {
				stack.push(Block::C);
			}
			_ => {}
		}
	}

	output.push_str("}");

	let mut file = File::create(".splat_tmp.c")?;
	file.write_fmt(format_args!("{}", output))?;

	if !Command::new("gcc")
		.arg("-O3")
		.arg(".splat_tmp.c").spawn().unwrap().wait().unwrap().success()
	{
		panic!("Failed to compile this fool.");
	}

	if !Command::new("strip")
		.arg("-s")
		.arg("a.out").spawn().unwrap().wait().unwrap().success()
	{
		panic!("Failed to compile this fool.");
	}

	fs::remove_file(".splat_tmp.c")?;

	Ok(())
}
